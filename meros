#!/usr/bin/python3

import subprocess
import logging
from pathlib import Path
import getopt
import sys
import os

from src.app_config import AppConfig
from src.vm_models import VMConfigLoader
from src.kernel_builder import KernelBuilder
from src.vm_manager import VMManager
from src.vm_build import VMBuilder
from src.ssh_manager import SSHManager

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hic:v", [
                                "help",
                                "kernel-build",
                                "get", "bootstrap", "build",
                                "init","shutdown",
                                "connect","push", "pull", "run",
                                "info", "log",
                                "output="
                                ])

    except getopt.GetoptError as err:
        print(err)
        AppConfig.display_help()
        sys.exit(2)
    output = None
    verbose = False

    logging.basicConfig(
            # filename = AppConfig.mos_path + '/LOG',
            format = '%(asctime)s::MerOS::%(levelname)s::%(message)s',
            datefmt = '%H:%M:%S',
            # level=logging.DEBUG if verbose else logging.INFO,
            level=logging.DEBUG,
            encoding = 'utf-8')

    for o, a in opts:
        if o == "-v":
            verbose = True

        elif o in ("--log"):
            AppConfig.display_log()
            sys.exit()

        elif o in ("-h", "--help"):
            AppConfig.display_help()
            sys.exit()

        elif o in ("--kernel-build"):
            kernel_builder = KernelBuilder()
            kernel_builder.kernel_clone()
            kernel_builder.kernel_build()

            sys.exit()

        ## When building, we will be chrooting in the newly created rootfs
        ## configuring local ( build-time ) packages-
        ## thus needing elevated ( root ) privileges
        ## ( See: mos/target_manage.py:104 )
        elif o in ("--build"):
            template = sys.argv[2]
            config_path = f"{AppConfig.mos_path}/templates/{template}/manifest.yml"

            config = VMConfigLoader.load_config(config_path)
            vm_builder = VMBuilder(config, template)

            vms_to_build = config.virtual_machines.keys()

            if not vms_to_build:
                logging.warning("No VMs specified and none found in config")
                return

            for vm_name in vms_to_build:
                if vm_name in config.virtual_machines:
                    AppConfig.elevate_privs()
                    vm_builder.build_vm(vm_name)
                    logging.info(f"Built {vm_name}")
                else:
                    logging.warning(f"VM {vm_name} not found in config")

        elif o in ("-i", "--init"):
            template = sys.argv[2]
            config_path = f"{AppConfig.mos_path}/templates/{template}/manifest.yml"

            # Load full config (bridges + VMs)
            # Initialize manager with full config
            config = VMConfigLoader.load_config(config_path)
            vm_manager = VMManager(config)

            # Determine Bridges to configure
            bridges_to_configure = list(config.bridges.keys())
            if not bridges_to_configure:
                logging.warning("No bridges defined in config")
                return

            for bridge_name in bridges_to_configure:
                AppConfig.elevate_privs()
                vm_manager.configure_bridge(bridge_name)
                logging.info(f"Processed bridge: {bridge_name}")

            # Determine VMs to start
            vms_to_start = config.virtual_machines.keys()

            if not vms_to_start:
                logging.warning("No VMs specified and none found in config")
                return

            for vm_name in vms_to_start:
                if vm_name in config.virtual_machines:
                    AppConfig.elevate_privs()
                    vm_manager.start_vm(vm_name)
                    logging.info(f"Started {vm_name}")
                else:
                    logging.warning(f"VM {vm_name} not found in config")


        elif o in ("--shutdown"):
            AppConfig.elevate_privs()
            template = sys.argv[2]
            config_path = f"{AppConfig.mos_path}/templates/{template}/manifest.yml"

            # Load full config (bridges + VMs)
            # Initialize manager with full config
            config = VMConfigLoader.load_config(config_path)
            vm_manager = VMManager(config)

            # Determine Bridges to delete
            bridges_to_delete = list(config.bridges.keys())
            if not bridges_to_delete:
                logging.warning("No bridges defined in config")
                return

            for bridge_name in bridges_to_delete:
                vm_manager.delete_bridge(bridge_name)
                logging.info(f"Deleted bridge: {bridge_name}")

            # Determine VMs to stop
            vms_to_stop = config.virtual_machines.keys()

            if not vms_to_stop:
                logging.warning("No VMs specified and none found in config")
                return

            for vm_name in vms_to_stop:
                if vm_name in config.virtual_machines:
                    vm_manager.stop_vm(vm_name)
                    logging.info(f"Stopped {vm_name}")
                else:
                    logging.warning(f"VM {vm_name} not found in config")

        elif o in ("-c", "--connect"):
            template = sys.argv[2]
            vm_name = sys.argv[3]

            config_path = f"{AppConfig.mos_path}/templates/{template}/manifest.yml"
            config = VMConfigLoader.load_config(config_path)

            vm_config = config.virtual_machines[vm_name]
            vm_ip_addr = vm_config.networks[0].ip_addr

            ssh_manager = SSHManager(config, template, vm_name, vm_ip_addr)
            ssh_manager.interactive_shell()


        elif o in ("--pull"):
            template = sys.argv[2]
            vm_name = sys.argv[3]

            config_path = f"{AppConfig.mos_path}/templates/{template}/manifest.yml"
            config = VMConfigLoader.load_config(config_path)

            vm_config = config.virtual_machines[vm_name]
            vm_ip_addr = vm_config.networks[0].ip_addr

            ssh_manager = SSHManager(config, template, vm_name, vm_ip_addr)
            ssh_manager.pull_files()

        elif o in ("--push"):
            template = sys.argv[2]
            vm_name = sys.argv[3]
            input_path = Path(sys.argv[4])
            absolute_path = (Path.cwd() / input_path).resolve()

            config_path = f"{AppConfig.mos_path}/templates/{template}/manifest.yml"
            config = VMConfigLoader.load_config(config_path)

            vm_config = config.virtual_machines[vm_name]
            vm_ip_addr = vm_config.networks[0].ip_addr

            ssh_manager = SSHManager(config, template, vm_name, vm_ip_addr)
            ssh_manager.push_file(absolute_path)

        elif o in ("--run"):
            template = sys.argv[2]
            vm_name = sys.argv[3]
            application = Path(sys.argv[4])

            config_path = f"{AppConfig.mos_path}/templates/{template}/manifest.yml"
            config = VMConfigLoader.load_config(config_path)

            vm_config = config.virtual_machines[vm_name]
            vm_ip_addr = vm_config.networks[0].ip_addr

            ssh_manager = SSHManager(config, template, vm_name, vm_ip_addr)
            ssh_manager.vm_run(application)

        ## TODO Fix
        elif o in ("--info"):
            template = sys.argv[2]
            config_path = f"{AppConfig.mos_path}/templates/{template}/manifest.yml"

            # Load full config (bridges + VMs)
            # Initialize manager with full config
            AppConfig.elevate_privs()
            config = VMConfigLoader.load_config(config_path)
            vm_manager = VMManager(config)
            for vm_name, status in vm_manager.get_all_statuses().items():
                print(f"{template}_{vm_name}: {'Running' if status else 'Stopped'}")

        else:
            print("Error")
            assert False, "unhandled option"

if __name__ == "__main__":
    main()
